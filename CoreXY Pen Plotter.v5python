{"mode":"Text","hardwareTarget":"brain","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\nl_motor = Motor(Ports.PORT10, GearSetting.RATIO_36_1, False)\nr_motor = Motor(Ports.PORT20, GearSetting.RATIO_36_1, False)\n\n\n# wait for rotation sensor to fully initialize\nwait(30, MSEC)\n\n\n# Make random actually random\ndef initializeRandomSeed():\n    wait(100, MSEC)\n    random = brain.battery.voltage(MV) + brain.battery.current(CurrentUnits.AMP) * 100 + brain.timer.system_high_res()\n    urandom.seed(int(random))\n      \n# Set random seed \ninitializeRandomSeed()\n\n\ndef play_vexcode_sound(sound_name):\n    # Helper to make playing sounds from the V5 in VEXcode easier and\n    # keeps the code cleaner by making it clear what is happening.\n    print(\"VEXPlaySound:\" + sound_name)\n    wait(5, MSEC)\n\n# add a small delay to make sure we don't print in the middle of the REPL header\nwait(200, MSEC)\n# clear the console to make sure we don't have the REPL in the console\nprint(\"\\033[2J\")\n\n#endregion VEXcode Generated Robot Configuration\n\n# ------------------------------------------\n# \n# \tProject:      VEXcode Project\n#\tAuthor:       VEX\n#\tCreated:\n#\tDescription:  VEXcode V5 Python Project\n# \n# ------------------------------------------\n\n# Library imports\nfrom vex import *\n\n# Begin project code\ntarget_speed = 100\n\n#Transformation Matrix Variables\nl_dir = [.5,-.5]\nr_dir = [.5,.5]\n\nt_matrix = [[0,0],[0,0]]\n\n#Distance Conversion Variables\nmm_to_deg = (35/130) * (1/20) * (84/36) * 360\n\n#Limits\nx_limit = [0, 260-50]\ny_limit = [0, 280-50]\n\ndef calculate_matrix():\n    global t_matrix\n    t_matrix = [l_dir[0], r_dir[0]], [l_dir[1], r_dir[1]]\n\n    #invert Matrix\n    det = t_matrix[0][0]*t_matrix[1][1] - t_matrix[0][1]*t_matrix[1][0]\n    temp = t_matrix[0][0]\n    t_matrix[0][0] = t_matrix[1][1]\n    t_matrix[1][1] = temp\n    t_matrix[1][0] *= -1\n    t_matrix[0][1] *= -1\n\n    t_matrix[0][0] /= det\n    t_matrix[0][1] /= det\n    t_matrix[1][0] /= det\n    t_matrix[1][1] /= det\n\ndef transform_coordinate(coor):\n    transformed = [0, 0]\n\n    for i in range(2):\n        s = 0\n        for j in range(2):\n            s += t_matrix[i][j] * coor[j]\n        transformed[i] = s\n\n    return transformed\n\ndef move_in_dir(dire, speed):\n    d = transform_coordinate(dire)\n    m = max(abs(dire[0]),abs(dire[1]))\n\n    #Correct speed\n    hypt = math.sqrt(d[0]**2 + d[1]**2)\n    d[0] *= speed/hypt\n    d[1] *= speed/hypt\n\n    l_motor.set_velocity(d[0])\n    r_motor.set_velocity(d[1])\n\ndef stop_motors():\n    l_motor.set_velocity(0, PERCENT)\n    r_motor.set_velocity(0, PERCENT)\n\ndef auto_home():\n    #Home Vertical\n    move_in_dir([0,-1], 50)\n    wait(0.25, SECONDS)\n    while (not check_spike_in_torque(.2)):\n        wait(0.1, SECONDS)\n\n    move_in_dir([0,1], 100)\n    wait(0.5, SECONDS)\n    stop_motors()\n    \n    wait(1, SECONDS)\n\n    #Home Horizontal\n    move_in_dir([-1,0], 50)\n    wait(0.25, SECONDS)\n    while (not check_spike_in_torque(.2)):\n        wait(0.1, SECONDS)\n\n    move_in_dir([1,0], 100)\n    wait(0.6, SECONDS)\n    stop_motors()\n    \n\n    l_motor.set_position(0, DEGREES)\n    r_motor.set_position(0, DEGREES)\n\ndef check_spike_in_torque(threshold):\n    torq = max(r_motor.torque(TorqueUnits.NM), l_motor.torque(TorqueUnits.NM))\n\n    brain.screen.clear_screen()\n    brain.screen.set_cursor(1, 1)\n    brain.screen.print(torq)\n    brain.screen.set_cursor(2, 1)\n    brain.screen.print(torq > threshold)\n\n    return torq > threshold\n\ndef current_pos():\n    pos = [0, 0]\n    l_dist = l_motor.position(DEGREES)\n    r_dist = r_motor.position(DEGREES)\n    for i in range(2):\n        pos[i] = l_dist * l_dir[i] + r_dist * r_dir[i]\n        pos[i] /= mm_to_deg\n    return pos\n\ndef move_to_pos(target):\n    #Keep Target within bounds\n    target[0] = min(max(target[0],x_limit[0]),x_limit[1])\n    target[1] = min(max(target[1],y_limit[0]),y_limit[1])\n\n    #Calculate the target motor position\n    cvt_target = transform_coordinate(target)\n    for i in range(2):\n        cvt_target[i] *= mm_to_deg\n    \n    #calculate the target direction based on current position \n    cur_pos = current_pos()\n    direction = [target[0] - cur_pos[0], target[1] - cur_pos[1]]\n\n    move_in_dir(direction, 50)\n    l_motor.spin_to_position(cvt_target[0], DEGREES, wait=False)\n    r_motor.spin_to_position(cvt_target[1], DEGREES, wait=False)\n    #move_in_dir(target, 50)\n\n    #wait until target reached\n    while abs(l_motor.position(DEGREES)-cvt_target[0])>5 and abs(r_motor.position(DEGREES)-cvt_target[1])>5:\n        wait(0.05, SECONDS)\n\n    #\n    brain.screen.clear_screen()\n    brain.screen.set_cursor(1, 1)\n    brain.screen.print(cvt_target[0], cvt_target[1])\n\n#setup\ncalculate_matrix()\n\n#start motors\nl_motor.spin(FORWARD)\nr_motor.spin(FORWARD)\nl_motor.set_max_torque(5, PERCENT)\nr_motor.set_max_torque(5, PERCENT)\n\n#actions\nauto_home()\nwait(1, SECONDS)\n\n\n\n#define square drawing\ndef center(target):\n    return [target[0] + x_limit[1]/2, target[1] + y_limit[1]/2]\n\nsquare = [\n    [-50, -50],\n    [50, -50],\n    [50, 50],\n    [-50, 50],\n    [-50, -50]\n]\n\ncircle = []\ncircle_points = 12\nsegment_angle = 2 * math.pi / circle_points\nradius = 50\nfor i in range(circle_points):\n    ang = i * segment_angle\n    circle.append([radius*math.cos(ang), radius*math.sin(ang)])\n\ndef draw_shape():\n    for pos in circle:\n        move_to_pos(center(pos))\n\n\n#move to start and wait for brain screen press to start\n#move_to_pos(center(square[0]))\nbrain.screen.pressed(draw_shape)\n\n#completion message\nbrain.screen.clear_screen()\nbrain.screen.set_cursor(1, 1)\nbrain.screen.print(\"Complete\")\n\nmove_in_dir([0,1], target_speed)\nwait(2, SECONDS)\nmove_in_dir([1,2], target_speed)\nwait(2, SECONDS)\nmove_in_dir([1,1], target_speed)\nwait(2, SECONDS)\nmove_in_dir([2,1], target_speed)\nwait(2, SECONDS)\nmove_in_dir([1,0], target_speed)","textLanguage":"python","robotConfig":[{"port":[10],"name":"l_motor","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio36_1"},"triportSourcePort":22},{"port":[20],"name":"r_motor","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio36_1"},"triportSourcePort":22}],"slot":4,"platform":"V5","sdkVersion":"20240802.15.00.00","appVersion":"4.0.8","fileFormat":"2.0.0","targetBrainGen":"First","v5Sounds":[{"name":"game over","url":"static/sounds/mixkit-arcade-retro-game-over-213.wav"}],"v5SoundsEnabled":false}